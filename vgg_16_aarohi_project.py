# -*- coding: utf-8 -*-
"""VGG-16 Aarohi project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a1KfBKJOHSZaEkKp-3jxAhOwCSk3WmwP
"""

from keras.models import Model
from keras.layers import Input,Dense,Conv2D,MaxPooling2D,GlobalAveragePooling2D,GlobalMaxPooling2D,Flatten
from keras.preprocessing import image
from keras.applications.imagenet_utils import preprocess_input
from keras.applications.imagenet_utils import decode_predictions
from keras import backend as k
from __future__ import print_function
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import cv2
!pip install --force-reinstall tensorflow
!python3 -m venv myenv
!source myenv/bin/activate
!pip install --force-reinstall tensorflow

import tensorflow as tf

import warnings


!pip install kaggle
import json
from zipfile import ZipFile
kaggle_credentails = json.load(open("kaggle.json"))
os.environ['KAGGLE_USERNAME'] = kaggle_credentails["username"]
os.environ['KAGGLE_KEY'] = kaggle_credentails["key"]
!kaggle datasets download -d robinreni/house-rooms-image-dataset
!ls
# Unzip the downloaded dataset
with ZipFile("house-rooms-image-dataset.zip", 'r') as zip_ref:
    zip_ref.extractall()

def vgg_updated(input_tensor=None,classes=2):
    input_shape=(300,300,3)
    img_input=Input(shape=input_shape)

    #Block1
     # Create variables outside the tf.function context
    with tf.init_scope():  # Ensures variables are created eagerly
      x=Conv2D(64,(3,3),activation='relu',padding='same',name='block1_conv1')(img_input)
      x=Conv2D(64,(3,3),activation='relu',padding='same',name='block1_conv2')(x)
      x=MaxPooling2D((2,2),strides=(2,2),name='block1_pool')(x)
    #Block2
    x=Conv2D(128,(3,3),activation='relu',padding='same',name='block2_conv1')(x)
    x=Conv2D(128,(3,3),activation='relu',padding='same',name='block2_conv2')(x)
    x=MaxPooling2D((2,2),strides=(2,2),name='block2_pool')(x)

    #Block3
    x=Conv2D(256,(3,3),activation='relu',padding='same',name='block3_conv1')(x)
    x=Conv2D(256,(3,3),activation='relu',padding='same',name='block3_conv2')(x)
    x=Conv2D(256,(3,3),activation='relu',padding='same',name='block3_conv3')(x)
    x=MaxPooling2D((2,2),strides=(2,2),name='block3_pool')(x)

    #Block4
    x=Conv2D(512,(3,3),activation='relu',padding='same',name='block4_conv1')(x)
    x=Conv2D(512,(3,3),activation='relu',padding='same',name='block4_conv2')(x)
    x=Conv2D(512,(3,3),activation='relu',padding='same',name='block4_conv3')(x)
    x=MaxPooling2D(2,2,name='block4_pool')(x)

    #Block5
    x=Conv2D(512,(3,3),activation='relu',padding='same',name='block5_conv1')(x)
    x=Conv2D(512,(3,3),activation='relu',padding='same',name='block5_conv2')(x)
    x=Conv2D(512,(3,3),activation='relu',padding='same',name='block5_conv3')(x)
    x=MaxPooling2D(2,2,name='block5_pool')(x)

    #Block6:Classification Block
    x=Flatten(name='Flatten')(x)
    x=Dense(4096,activation='relu',name='fc1')(x)
    x=Dense(4096,activation='relu',name='fc2')(x)
    x=Dense(classes,activation='softmax',name='predictions')(x)

    model=Model(inputs=img_input,outputs=x,name='VGG_updated')
    return model

dataset_path=os.listdir("House_Room_Dataset")
print(dataset_path)
room_types=os.listdir("House_Room_Dataset")
remove=['Kitchen', 'Bathroom','Livingroom']
room_types=[i for i in room_types if i not in remove]
print(room_types)

print(room_types)

rooms=[]
im_paths=[]
labels=[]
for room_type in room_types:
    all_rooms=os.listdir(os.path.join("House_Room_Dataset"+"/"+room_type))
    print(all_rooms)
    for room in all_rooms:
         labels.append(room_type)
         rooms.append((room_type,str("House_Room_Dataset")+"/"+room_type+"/"+room))
         im_paths.append(str("House_Room_Dataset")+"/"+room_type+"/"+room)
print(labels[:])
print(rooms[:])
print(im_paths[:])

df=pd.DataFrame(data=rooms,columns=['room_type','image_path'])
df

room_count=df['room_type'].value_counts()
print('Total number of rooms in dataset:',len(df['room_type']))
print('Rooms in each category:\n',room_count)

images=[]

for i in im_paths:
    img=cv2.imread(i)
    img=cv2.resize(img,(300,300))
    images.append(img)
images

images=np.array(images)
images=images.astype('float32')/255.0
print(images)
print(labels)

images.shape

from sklearn.preprocessing import LabelEncoder,OneHotEncoder
y=labels
y_LE=LabelEncoder()
y=y_LE.fit_transform(y)
print(y)
y=y.reshape(-1,1)
OHE=OneHotEncoder()
Y=OHE.fit_transform(y)
print(Y,'\n',Y.shape)

# Add the tf.config options
tf.config.set_soft_device_placement(True)
tf.config.experimental.set_visible_devices([], 'GPU')

model=vgg_updated(classes=2)
model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'])



from sklearn.feature_extraction.text import CountVectorizer,TfidfTransformer
from sklearn.utils import shuffle
from sklearn.model_selection import train_test_split
images,Y=shuffle(images,Y,random_state=1)
X_train,X_test,y_train,y_test=train_test_split(images,Y,test_size=0.2,random_state=1)

# Convert sparse matrices to dense arrays and then to integer labels
y_train_labels = y_train.toarray().argmax(axis=1)  # Convert to dense array and get class indices
y_test_labels = y_test.toarray().argmax(axis=1)    # Convert to dense array and get class indices

# Convert integer labels to one-hot encoded format using Keras's to_categorical
from tensorflow.keras.utils import to_categorical
y_train = to_categorical(y_train_labels, num_classes=2) # Use integer labels
y_test = to_categorical(y_test_labels, num_classes=2)   # Use integer labels


print(X_train.shape,'\n',X_test.shape,'\n',y_train.shape,'\n',y_test.shape)

model.fit(X_train,y_train,epochs=10,batch_size=32)

preds=model.evaluate(X_test,y_test)
print("Loss= "+str(preds[0]))
print("Test Accuracy= "+str(preds[1]))

